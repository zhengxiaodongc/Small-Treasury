### number数字类型
>包含：常规数字，NaN
### NaN
> not a numder: 不是一个数，但它率属于数字类型
- script(导入js)
- console.log([val]):在控制台输出内容
- NaN和任何值都不能相等（包括自己都不相等所以我们不能用相等的方式判断是否有效数字。
### isNaN
- 检测一个值是否为非有效数字，如果不是有效数字返回TRUE（处）,反之是有效数字返回FALSE。
- 在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，如果不是，先基于numder（）这个方法，把值转换为数字类型，然后在检测。
### 把其他类型值转换为数字类型
- Numder([wal])
把字符串转换为数字，只要字符串中包含任意一个非有效数字字符（第一个点除外）结果都是NaN，空字符串会变成为数字零。
- console.log(numder(true));//=>1
- console.log(numder(false));//=>0
- console.log(numder(null));//=>1
- console.log(numder(undefined));//=>NaN
- 把引用数据类型转换为数字，是先把他基于tostring方法转换为字符串，然后在转换为数字。
- parseInt(整数)/parseFloat（小数）([val],[进制])：也是转换为数字的方法，对于字符串来说，它是从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不在找了），把找到的当做数字返回。
- ==进行比较的时候，可能要出现把其他类型值转换为数字。
### string字符串数据类型
> 所有用单引号、双引号、反引号（撇 ES6模板字符串）包起来的都是字符串。
### boolean布尔数据类型
> 只有两个值（true/false)
### 把其他类型值转换为布尔类型
> 只有0、NaN、null、unefinde 五个值转换为FALSE,其余都转换为TRUE(而且没有任何的特殊情况)
- Boolean([val])
- !/!!
- 条件判断
- ！取反（先转为布尔，然后取反）
- ！！=Boolean(只相当于转换为布尔)
- 如果条件只是一个值，不是==/===/!=/>= 等这些比较，是要把这个值先转换为布尔类型，然后验证真假。
### null/undefined
> null和undefined都代表的事没有
- null：意料之中（一般都是开始不知道值，我们手动先设置为null，然后在给与赋值操作）。
- 一般最好用null作为初始的空值，因为零不是空值，它在栈内存中有自己的存储空间（占了位置）。
- undefined:意料之外（不是我能决定的）
- 创建一个变量没有赋值，默认值是undefined。
### object对象数据类型-普通对象
>{[key]:[value],...} 任何一个对象都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）。
> 数组是
### 浏览器想要执行JS代码：
- 从电脑内存中分配出一块内存，用来执行代码（栈内存=>Stack）
- 分配一个主线程用来自上而下执行JS代码
- 栈内存：变量存储空间、值存储空间 
- 复杂值的存储：
- 1.在内存中分配出一块新内存，用来存储引用类型值（堆内存=>heap）=>内存有一个16进制地址
- 2.把对象中的键值对依次存储到堆内存中
- 3.把堆内存地址和变量关联起来
> 基本类型：按值操作（直接操作的是值）所以也叫做值类型。
> 引用类型：操作的是对内存的地址（按引用的地址操作） 